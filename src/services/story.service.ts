import * as storyRepository from "../repositories/story.repository";
import * as stageRepository from "../repositories/stage.repository";
import * as likeRepository from "../repositories/like.repository";
import { openai } from "../utils/openai";
import { IStory } from "../types/story";

// get all stories
export async function get(filter: Partial<IStory>, start = 0, limit = 100, orderBy = "dsc") {
   const stories = await storyRepository.get(filter, start, limit, orderBy);
   const total = await storyRepository.count(filter);
   return { stories, total };
}

// get random premise generated by AI
export async function getRandomPremise() {
   const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
         {
            role: "system",
            content: [
               {
                  type: "text",
                  text: "You are an interesting children story teller. Create an interesting premise for short kids story. It must exclude magic. Keep it real. The time setting could be present, past or future. The main character could be anything. Keep it short. Example: A boy trying to fly using a giant kite. CRITICAL: the premise is only 1 sentence and short.",
               },
            ],
         },
      ],
      temperature: 1.5,
      max_tokens: 2048,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: {
         type: "json_schema",
         json_schema: {
            name: "premise_schema",
            schema: {
               type: "object",
               required: ["premise"],
               properties: {
                  premise: {
                     type: "string",
                     description: "The short kids story premise",
                  },
               },
               additionalProperties: false,
            },
            strict: true,
         },
      },
   });

   return JSON.parse(response.choices[0].message?.content as string);
}

// validate user own premise using AI
export async function validatePremise(premise: string) {
   const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
         {
            role: "system",
            content: [
               {
                  text: "You are a child story teller. Given a story premise. Validate whether the premise suitable for kids or not. If invalid, suggest a premise for a kids short story related with given invalid premise. If valid, refine the premise given, so it gets more interesting. CRITICAL: Your generated premise must be 1 sentence and short, don't include magic, the character could be anything, the place could be everywhere, the time setting could be past, present or the future.",
                  type: "text",
               },
            ],
         },
         {
            role: "user",
            content: premise,
         },
      ],
      temperature: 1.2,
      max_tokens: 2048,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: {
         type: "json_schema",
         json_schema: {
            name: "validation_result",
            strict: true,
            schema: {
               type: "object",
               required: ["isValid", "suggestedPremise"],
               properties: {
                  isValid: {
                     type: "boolean",
                     description: "Indicates whether the validation succeeded.",
                  },
                  suggestedPremise: {
                     type: "string",
                     description: "The suggested premise or refined premise",
                  },
               },
               additionalProperties: false,
            },
         },
      },
   });

   return JSON.parse(response.choices[0].message?.content as string);
}

// create a new story only by premise, all other data is marked temporary or ongoing
export function createNewStory(data: { userId: string; premise: string }) {
   const { userId, premise } = data;
   const MIN_STAGE_NUMBER = 4;
   const MAX_STAGE_NUMBER = 7;

   const storyData = {
      userId,
      title: "Ongoing Story ...",
      description: premise + " [temporary]",
      thumbnail: "",
      premise,
      context: "",
      isFinish: false,
      maxStage: MIN_STAGE_NUMBER + Math.floor(Math.random() * (MAX_STAGE_NUMBER - MIN_STAGE_NUMBER)),
   };

   const newStory = storyRepository.create(storyData);
   return newStory;
}

// complete a story metadata using AI (when a story is finished)
export async function completeStoryMetadata(storyId: string) {
   const story = (await storyRepository.getById(storyId)) as IStory;
   const { context } = story;

   const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
         {
            role: "system",
            content: [
               {
                  type: "text",
                  text: "Given a kids story, create a suitable title and description for the story. Description is 2 sentences or less. Do not sound like a commercial. Do not try to convice reader to read the story.",
               },
            ],
         },
         {
            role: "user",
            content: context,
         },
      ],
      temperature: 1,
      max_tokens: 2048,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      response_format: {
         type: "json_schema",
         json_schema: {
            name: "json_schema",
            strict: true,
            schema: {
               type: "object",
               properties: {
                  title: {
                     type: "string",
                     description: "The title of the story object.",
                  },
                  description: {
                     type: "string",
                     description: "A description of the story.",
                  },
               },
               required: ["title", "description"],
               additionalProperties: false,
            },
         },
      },
   });

   const { title, description } = JSON.parse(response.choices[0].message?.content as string);

   // TODO:
   // update the thumbnail
   const lastStage = (await stageRepository.get({ storyId, stageNumber: 0 }))[0];

   const storyUpdated = storyRepository.update(storyId, { title, description, thumbnail: lastStage.place as string });
   return storyUpdated;
}

// delete a story and all its stages
export async function deleteStoryAndStages(storyId: string) {
   const deletedStory = await storyRepository.deleteById(storyId);
   const deletedStages = await stageRepository.deleteByStoryId({ storyId });
   return { deletedStory, deletedStages };
}

// update a story
export async function update(storyId: string, data: Partial<IStory>) {
   const storyUpdated = storyRepository.update(storyId, data);
   return storyUpdated;
}

// get liked stories
export async function getLikedStories(userId: string, start = 0, limit = 100) {
   const likedStories = await likeRepository.get({ userId }, start, limit);
   const totalLikedStories = await likeRepository.count({ userId });

   return { likedStories, totalLikedStories };
}
